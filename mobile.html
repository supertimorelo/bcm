<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>ROY — Mobile</title>
  <style>
    :root{
      /* Requested sizing */
      --draw-w: min(80vw, 420px);     /* Roy + frame + tirage */
      --ticket-w: min(65vw, 360px);   /* Scratch ticket */

      --shadow: 0 18px 60px rgba(0,0,0,.35);
      --text: rgba(255,255,255,.92);

      /* Scratch.png inner transparent window (measured from the provided asset) */
      --hole-left: 11.40%;
      --hole-top: 31.35%;
      --hole-w: 77.85%;
      --hole-h: 40.10%;
      --hole-radius: 14px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";
      color: var(--text);
      background: url("bgmob.png") center / cover no-repeat;
      overflow-x: hidden;
    }

    .safe{
      padding-top: calc(env(safe-area-inset-top) + 14px);
      padding-left: calc(env(safe-area-inset-left) + 14px);
      padding-right: calc(env(safe-area-inset-right) + 14px);
      padding-bottom: calc(env(safe-area-inset-bottom) + 18px);
      min-height: 100%;
      display:flex;
      justify-content:center;
      align-items:flex-start;
    }

    .app{
      width: 100%;
      max-width: 520px;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap: 18px;
    }

    /* Roy + frame stack */
    .draw-stack{
      width: var(--draw-w);
      margin-top: 40px; /* requested */
      display:flex;
      flex-direction:column;
      align-items:center;
      position: relative;
      filter: drop-shadow(var(--shadow));
    }

    /* Roy + extra layer effect */
    .roy-wrap{
      width: 92%;
      position: relative;
      z-index: 1; /* behind the frame */
      margin-bottom: -42%;
      pointer-events:none;
      user-select:none;
      -webkit-user-drag:none;
      opacity: .98;
    }
    .roy-wrap::before{
      content:"";
      position:absolute;
      inset:-8%;
      border-radius: 24px;
      background:
        radial-gradient(circle at 30% 18%, rgba(255,255,255,.55), rgba(255,255,255,0) 55%),
        linear-gradient(120deg,
          rgba(120,240,255,0) 0%,
          rgba(170,120,255,.42) 28%,
          rgba(255,200,90,.30) 55%,
          rgba(120,240,255,0) 82%,
          rgba(120,240,255,0) 100%);
      mix-blend-mode: screen;
      filter: blur(10px);
      opacity: .62;
      animation: roySweep 3.6s ease-in-out infinite;
      pointer-events:none;
    }
    @keyframes roySweep{
      0%   { transform: translateX(-10%) rotate(-2deg); opacity:.50; }
      50%  { transform: translateX( 10%) rotate( 2deg); opacity:.75; }
      100% { transform: translateX(-10%) rotate(-2deg); opacity:.50; }
    }

    .roy{
      width: 100%;
      height:auto;
      display:block;
      pointer-events:none;
      user-select:none;
      -webkit-user-drag:none;
      filter:
        drop-shadow(0 0 18px rgba(170,120,255,.28))
        drop-shadow(0 0 34px rgba(255,140,220,.16));
    }

    .frame-wrap{
      width: 100%;
      position: relative;
      z-index: 2;
      user-select:none;
      -webkit-user-drag:none;
      cursor: pointer;
      touch-action: manipulation;
    }

    .frame-img{
      width:100%;
      height:auto;
      display:block;
      user-select:none;
      -webkit-user-drag:none;
      pointer-events:none;
    }

    /* Balls overlay inside frame */
    .balls{
      position:absolute;
      left: 7%;
      right: 7%;
      top: 18%;
      height: 42%;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      padding: 6px 4px;
      pointer-events:none; /* click goes to frame-wrap */
    }

    .ball{
      flex: 1 1 0;
      aspect-ratio: 1 / 1;
      max-width: 64px;
      border-radius: 999px;
      display:flex;
      align-items:center;
      justify-content:center;

      font-weight: 950;
      font-size: clamp(16px, 4.8vw, 26px);
      letter-spacing: .5px;
      color: rgba(255,255,255,.96);
      text-shadow:
        0 2px 5px rgba(0,0,0,.38),
        0 0 14px rgba(0,0,0,.24);

      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.98), rgba(255,255,255,.72) 28%, rgba(170,150,255,.55) 56%, rgba(95,70,210,.42));
      border: 2px solid rgba(255,255,255,.22);
      box-shadow:
        inset 0 3px 10px rgba(255,255,255,.22),
        0 12px 22px rgba(0,0,0,.30);
      transform: translateZ(0);
      position: relative;
      overflow: hidden;
    }
    .ball::after{
      content:"";
      position:absolute;
      inset: 10%;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.22);
      box-shadow: inset 0 10px 18px rgba(255,255,255,.10);
      pointer-events:none;
    }
    .ball::before{
      content:"";
      position:absolute;
      left: 14%;
      top: 12%;
      width: 52%;
      height: 40%;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.65), rgba(255,255,255,0) 70%);
      transform: rotate(-14deg);
      pointer-events:none;
      opacity:.95;
    }

    .ball.ball--green{
      background: radial-gradient(circle at 30% 30%,
        rgba(255,255,255,.98) 0%,
        rgba(210,255,235,.78) 24%,
        rgba(60,235,150,.78) 58%,
        rgba(10,150,85,.62) 100%);
      border-color: rgba(140,255,205,.35);
      box-shadow:
        inset 0 3px 10px rgba(255,255,255,.22),
        0 12px 22px rgba(0,0,0,.30),
        0 0 26px rgba(60,255,170,.24);
    }
    .ball.ball--red{
      background: radial-gradient(circle at 30% 30%,
        rgba(255,255,255,.98) 0%,
        rgba(255,220,220,.78) 24%,
        rgba(255,90,110,.72) 58%,
        rgba(170,30,55,.58) 100%);
      border-color: rgba(255,170,185,.32);
      box-shadow:
        inset 0 3px 10px rgba(255,255,255,.22),
        0 12px 22px rgba(0,0,0,.30),
        0 0 26px rgba(255,90,110,.22);
    }

    .ball.reveal{ animation: pop .28s ease-out; }
    @keyframes pop{
      0%{ transform: scale(.92); filter: brightness(1); }
      60%{ transform: scale(1.06); filter: brightness(1.10) saturate(1.05); }
      100%{ transform: scale(1.0); filter: brightness(1) saturate(1); }
    }

    /* Scratch ticket */
    .scratch-wrap{
      width: var(--ticket-w);
      margin-top: 60px; /* requested */
      position: relative;
      filter: drop-shadow(var(--shadow));
      user-select:none;
      -webkit-user-drag:none;
    }

    .scratch-img{
      width:100%;
      height:auto;
      display:block;
      position: relative;
      z-index: 3; /* always on top */
      user-select:none;
      -webkit-user-drag:none;
      pointer-events:none;
    }

    .scratch-hole{
      position:absolute;
      left: var(--hole-left);
      top: var(--hole-top);
      width: var(--hole-w);
      height: var(--hole-h);
      z-index: 1;
      border-radius: var(--hole-radius);
      background: linear-gradient(180deg, rgba(235,235,235,.92), rgba(195,195,195,.92));
      border: 1px solid rgba(255,255,255,.22);
      box-shadow: inset 0 10px 22px rgba(0,0,0,.12);
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 10px;
      text-align:center;
    }

    .login-btn{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width: 100%;
      height: 100%;
      border-radius: 12px;

      text-decoration:none;
      font-weight: 900;
      font-size: clamp(16px, 4.4vw, 22px);
      color: rgba(30,30,30,.95);
      background: rgba(255,255,255,.60);
      border: 1px solid rgba(0,0,0,.12);
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,.5),
        0 10px 18px rgba(0,0,0,.18);
    }
    .login-btn:active{ transform: scale(.99); }

    .scratch-canvas{
      position:absolute;
      left: var(--hole-left);
      top: var(--hole-top);
      width: var(--hole-w);
      height: var(--hole-h);
      z-index: 2; /* between hole and png border */
      border-radius: var(--hole-radius);
      touch-action: none;
      cursor: grab;
    }
    .scratch-canvas.is-done{
      opacity: 0;
      pointer-events: none;
      transition: opacity .25s ease;
    }

    .footer-space{ height: 10px; }
  </style>
</head>
<body>
  <div class="safe">
    <main class="app">
      <section class="draw-stack" aria-label="Tirage">
        <div class="roy-wrap">
          <img class="roy" src="Roy1.png" alt="" />
        </div>

        <div class="frame-wrap" id="frameTap" role="button" aria-label="Relancer le tirage (tapez)">
          <img class="frame-img" src="frame.png" alt="" />
          <div class="balls" id="balls">
            <div class="ball" aria-label="Boule 1">-</div>
            <div class="ball" aria-label="Boule 2">-</div>
            <div class="ball" aria-label="Boule 3">-</div>
            <div class="ball" aria-label="Boule 4">-</div>
            <div class="ball" aria-label="Boule 5">-</div>
          </div>
        </div>
      </section>

      <section class="scratch-wrap" aria-label="Scratch & Win">
        <div class="scratch-hole">
          <a class="login-btn" href="https://x.com" target="_blank" rel="noopener">Login with X</a>
        </div>
        <canvas class="scratch-canvas" id="scratchCanvas" aria-label="Zone à gratter"></canvas>
        <img class="scratch-img" src="scratch.png" alt="Scratch & Win" />
      </section>

      <div class="footer-space"></div>
    </main>
  </div>

  <script>
    // ---------- DRAW ----------
    const ballEls = Array.from(document.querySelectorAll("#balls .ball"));
    const frameTap = document.getElementById("frameTap");

    const AUTO_RESTART_MS = 2500;  // pause between draws
    let drawTimer = null;
    let isDrawing = false;

    function sendResultToParent(result){
      try{
        if(window.parent && window.parent !== window){
          window.parent.postMessage({ type: "drawResult", ...result }, "*");
        }
      }catch(e){}
    }

    function uniqueRandomInts(count, min, max){
      const set = new Set();
      while(set.size < count){
        const n = Math.floor(Math.random() * (max - min + 1)) + min;
        set.add(n);
      }
      return Array.from(set);
    }

    function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }
    function randomBallClass(){ return (Math.random() < 0.5) ? "ball--green" : "ball--red"; }

    function resetBalls(){
      ballEls.forEach(b => {
        b.textContent = "-";
        b.classList.remove("reveal","ball--green","ball--red");
      });
    }

    async function runDrawOnce(){
      if(isDrawing) return;
      isDrawing = true;

      try{
        resetBalls();
        await sleep(220);

        const picks = uniqueRandomInts(5, 1, 50);
        const result = [];

        for(let i=0;i<picks.length;i++){
          const cls = randomBallClass();
          const b = ballEls[i];

          b.classList.remove("ball--green","ball--red");
          b.classList.add(cls);

          result[i] = { n: picks[i], color: (cls === "ball--green" ? "green" : "red") };

          b.textContent = String(picks[i]);
          b.classList.remove("reveal");
          void b.offsetWidth;
          b.classList.add("reveal");

          await sleep(650);
        }

        // Send full result to parent page
        sendResultToParent({ ts: Date.now(), picks: result });

      }catch(err){
        console.error("Draw error:", err);
      }finally{
        isDrawing = false;
        // schedule next draw
        clearTimeout(drawTimer);
        drawTimer = setTimeout(() => { runDrawOnce(); }, AUTO_RESTART_MS);
      }
    }

    function restartDrawNow(){
      clearTimeout(drawTimer);
      isDrawing = false;
      runDrawOnce();
    }

    frameTap.addEventListener("click", restartDrawNow);

    // Start automatically
    runDrawOnce();

    // ---------- SCRATCH ----------
    const canvas = document.getElementById("scratchCanvas");
    const ctx = canvas.getContext("2d", { willReadFrequently: true });

    let isDown = false;
    let last = null;
    let brushRadius = 22;
    let checkTimer = null;
    let done = false;

    function resizeCanvasAndPaint(){
      const rect = canvas.getBoundingClientRect();
      const dpr = Math.max(1, window.devicePixelRatio || 1);

      canvas.width = Math.floor(rect.width * dpr);
      canvas.height = Math.floor(rect.height * dpr);

      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      paintGold(rect.width, rect.height);

      brushRadius = Math.max(18, Math.min(rect.width, rect.height) * 0.18);
      done = false;
      canvas.classList.remove("is-done");
      canvas.style.pointerEvents = "auto";
    }

    function paintGold(w, h){
      ctx.globalCompositeOperation = "source-over";
      ctx.clearRect(0,0,w,h);

      const g = ctx.createLinearGradient(0,0,w,h);
      g.addColorStop(0.00, "rgba(255, 233, 150, 0.98)");
      g.addColorStop(0.25, "rgba(255, 200, 80, 0.98)");
      g.addColorStop(0.55, "rgba(255, 240, 170, 0.98)");
      g.addColorStop(0.80, "rgba(220, 160, 60, 0.98)");
      g.addColorStop(1.00, "rgba(255, 220, 120, 0.98)");

      ctx.fillStyle = g;
      ctx.fillRect(0,0,w,h);

      for(let i=0;i<350;i++){
        const x = Math.random() * w;
        const y = Math.random() * h;
        const r = Math.random() * 1.6 + 0.4;
        const a = Math.random() * 0.22;
        ctx.beginPath();
        ctx.fillStyle = `rgba(255,255,255,${a})`;
        ctx.arc(x,y,r,0,Math.PI*2);
        ctx.fill();
      }

      ctx.globalAlpha = 0.18;
      ctx.fillStyle = "white";
      ctx.beginPath();
      ctx.ellipse(w*0.25, h*0.25, w*0.55, h*0.28, -0.35, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    function getPos(e){
      const rect = canvas.getBoundingClientRect();
      const clientX = (e.touches && e.touches[0]) ? e.touches[0].clientX : e.clientX;
      const clientY = (e.touches && e.touches[0]) ? e.touches[0].clientY : e.clientY;
      return { x: clientX - rect.left, y: clientY - rect.top, w: rect.width, h: rect.height };
    }

    function scratchTo(x, y){
      ctx.globalCompositeOperation = "destination-out";
      ctx.beginPath();
      ctx.arc(x, y, brushRadius, 0, Math.PI * 2);
      ctx.fill();
    }

    function scratchLine(a, b){
      ctx.globalCompositeOperation = "destination-out";
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.lineWidth = brushRadius * 2;
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.stroke();
    }

    function scheduleCheck(w,h){
      if(done) return;
      if(checkTimer) return;
      checkTimer = setTimeout(() => {
        checkTimer = null;
        tryFinish(w,h);
      }, 240);
    }

    function tryFinish(w,h){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const img = ctx.getImageData(0,0,Math.floor(w*dpr), Math.floor(h*dpr)).data;

      let cleared = 0;
      const step = 24;
      for(let i=3;i<img.length;i+=step){
        if(img[i] === 0) cleared++;
      }
      const sampledTotal = Math.floor(img.length/step);
      const ratio = cleared / sampledTotal;

      if(ratio > 0.55){
        done = true;
        canvas.classList.add("is-done");
        canvas.style.pointerEvents = "none";
      }
    }

    function onDown(e){
      if(done) return;
      isDown = true;
      last = getPos(e);
      scratchTo(last.x, last.y);
      scheduleCheck(last.w, last.h);
      canvas.style.cursor = "grabbing";
      e.preventDefault();
    }

    function onMove(e){
      if(!isDown || done) return;
      const p = getPos(e);
      if(last){ scratchLine(last, p); }
      else{ scratchTo(p.x, p.y); }
      last = p;
      scheduleCheck(p.w, p.h);
      e.preventDefault();
    }

    function onUp(){
      isDown = false;
      last = null;
      canvas.style.cursor = "grab";
    }

    canvas.addEventListener("pointerdown", onDown);
    canvas.addEventListener("pointermove", onMove);
    window.addEventListener("pointerup", onUp);
    window.addEventListener("pointercancel", onUp);

    const ro = new ResizeObserver(() => resizeCanvasAndPaint());
    ro.observe(canvas);
    window.addEventListener("load", resizeCanvasAndPaint);
  </script>
</body>
</html>
